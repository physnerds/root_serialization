<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROOT SERIALIZATION: root_serialization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROOT SERIALIZATION
   </div>
   <div id="projectbrief">Look at the README File</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">root_serialization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Doxygen produced page is available here <a href="https://physnerds.github.io/root_serialization/md_README.html">https://physnerds.github.io/root_serialization/md_README.html</a> This is a testing structure for doing performance experiments with various I/O packages from within an multi-threaded program. The program mimics behaviors common for HEP data processing frameworks.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Getting started</h1>
<p>The CMakeLists.txt uses 3rd party packages from /cvmfs which are identical to the packages used by the CMS experiment's CMSSW_11_2_0_pre6 software release. No CMS code is needed to build the code from this repository. CMS header files and shared libraries are needed if data files containing CMS data are being read.</p>
<p>To build</p>
<div class="fragment"><div class="line">$ git clone &lt;root_serialization URL&gt;</div>
<div class="line">$ mkdir build-root-serialization</div>
<div class="line">$ cd build-root-serialization</div>
<div class="line">$ cmake &lt;path to root_serialization&gt; \</div>
<div class="line">  -DROOT_DIR=path_to_ROOT_cmake_targets \</div>
<div class="line">  [-DTBB_DIR=path_to_tbb_cmake_targets] \</div>
<div class="line">  [-DZSTD_DIR=path_to_zstd_cmake_targets] \</div>
<div class="line">  [-DLZ4_DIR=path_to_lz4_cmake_targets]</div>
<div class="line">$ make [-j N]</div>
</div><!-- fragment --><p>This will create the executable <code>threaded_io_test</code>.</p>
<p>If no cmake target exists for your installation of lz4, you can replace the cmake command above with</p>
<div class="fragment"><div class="line">$ cmake &lt;path to root_serialization&gt; \</div>
<div class="line">  -DCMAKE_PREFIX_PATH=path_to_lz4_install \</div>
<div class="line">  -DROOT_DIR=path_to_ROOT_cmake_targets \</div>
<div class="line">  [-DTBB_DIR=path_to_tbb_cmake_targets] \</div>
<div class="line">  [-DZSTD_DIR=path_to_zstd_cmake_targets] \</div>
<div class="line">  [-DLZ4_DIR=path_to_lz4_install]</div>
<div class="line">$ make [-j N]</div>
</div><!-- fragment --><p>where <code>path_to_lz4_install</code> is the path to the folder holding the <code>include</code> and <code>lib</code> directories containing the files for lz4.</p>
<p>Note that CMake can use some of the information from ROOT's CMake configuration to infer the build information for TBB, zstd, and lz4. If the ROOT runtime is setup, one can use <code>-DROOT_DIR=$ROOTSYS/cmake</code>.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
threaded_io_test design</h1>
<p>The testing structure has 3 customizable component types</p><ol type="1">
<li><code>Source</code>s: These supply the <em>event</em> data products used for testing.</li>
</ol>
<ol type="1">
<li><code>Outputer</code>s: These read the <em>event</em> data products. Some Outputers also write that data out for storage.</li>
</ol>
<ol type="1">
<li><code>Waiter</code>s: These get called for each <em>event</em> data product after the data products are read from testing. The <code>Outputer</code> is called once the <code>Waiter</code> has finished its asynchronous callback for the data product. This allows tuning the timing of events to better mimic actual HEP data processing.</li>
</ol>
<p>The testing structure can process multiple <em>events</em> concurrently. The processing of an <em>event</em> is handled by a <code>Lane</code>. Concurrent <em>events</em> are then done by having multiple <code>Lane</code>s.</p>
<p>All <code>Lane</code>s share the same <code>Source</code>, <code>Waiter</code>, and <code>Outputer</code>. Therefore all three of these types are required to be thread safe.</p>
<p>The way data is processed is as follows:</p><ol type="1">
<li>When a <code>Lane</code> is no longer processing an <em>event</em> it requests a new one from the system. The system advances an atomic counter and tells the <code>Lane</code> to use the <em>event</em> associated with that index.</li>
</ol>
<ol type="1">
<li>The <code>Lane</code> then passes the <em>event</em> index to the <code>Source</code> and asks it to asynchronously retrieve the <em>event</em> data products.</li>
</ol>
<ol type="1">
<li>Once the <code>Source</code> has retrieved the data products, it signals to the <code>Waiter</code>s to run asynchronously.</li>
</ol>
<ol type="1">
<li>Once the<code>Waiter</code> has finished with each data product, the system signals to the <code>Outputer</code> that the particular <em>event</em> data product is available for the <code>Outputer</code>. The <code>Outputer</code> can then asynchronously process that data product.</li>
</ol>
<ol type="1">
<li>Once the <code>Outputer</code> has finished with all the data products, the system signals the <code>Outputer</code> that the <em>event</em> has finished. The <code>Outputer</code> can then do additional asynchronous work.</li>
</ol>
<ol type="1">
<li>When the <code>Outputer</code> finishes its end of <em>event</em> work, the <code>Lane</code> is considered to be done with that <em>event</em> and the cycle repeats.</li>
</ol>
<h1><a class="anchor" id="autotoc_md3"></a>
Running tests</h1>
<p>The <code>threaded_io_test</code> takes the following command line arguments </p><div class="fragment"><div class="line">threaded_io_test -s &lt;Source configuration&gt; [-t &lt;# threads&gt;] [--use-IMT=&lt;T/F&gt;] [-l &lt;# conconcurrent events&gt;] [-w &lt;Waiter configuration&gt;] [ -n &lt;max # events&gt;] [-o &lt;Outputer configuration&gt;]</div>
</div><!-- fragment --><ol type="1">
<li><code>--source, -s</code> <code>&lt;Source configuration&gt;</code> : which <code>Source</code> to use and any additional information needed to configure it. Options are described below.</li>
</ol>
<ol type="1">
<li><code>--num-threads, -t</code> <code>&lt;# threads&gt;</code> : number of threads to use in the job.</li>
</ol>
<ol type="1">
<li><code>--use-IMT</code> turn on or off ROOT's implicit multithreaded (IMT). Default is off.</li>
</ol>
<ol type="1">
<li><code>--num-lanes, -l</code> <code>&lt;# concurrent events&gt;</code> : number of concurrent <em>events</em> (that is <code>Lane</code>s) to use. Best if number of events is less than or equal to number of threads. Default is the value used for <code>--num-threads</code>.</li>
</ol>
<ol type="1">
<li><code>--waiter, -w</code> <code>&lt;Waiter configuration&gt;</code> : used to specify which <code>Waiter</code> to use and any additional information needed to configure it. The exact options are described below. Default is '' which causes no <code>Waiter</code> to be used.</li>
</ol>
<ol type="1">
<li><code>--num-events, -n</code> <code>&lt;max # events&gt;</code> : max number of events to process in the job. Default is largest possible 64 bit value.</li>
</ol>
<ol type="1">
<li><code>--outputer, -o</code> <code>&lt;Outputer configuration&gt;</code> : used to specify which <code>Outputer</code> to use and any additional information needed to configure it. The exact options are described below. Default is <code>DummyOutputer</code>.</li>
</ol>
<h1><a class="anchor" id="autotoc_md4"></a>
Available Components</h1>
<h2><a class="anchor" id="autotoc_md5"></a>
Sources</h2>
<h3><a class="anchor" id="autotoc_md6"></a>
EmptySource</h3>
<p>Does not generate any <em>event</em> data products. Specify by just using its name, e.g. </p><div class="fragment"><div class="line">&gt; threaded_io_test -s EmptySource -t 1 -n 10</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md7"></a>
TestProductsSource</h3>
<p>Generates a fixed set of data products for C++ types known by ROOT. Specify by just using its name, e.g. </p><div class="fragment"><div class="line">&gt; threaded_io_test -s TestProductsSource -t 1 -n 10</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8"></a>
ReplicatedRootSource</h3>
<p>Reads a standard ROOT file. Each concurrent Event has its own replica of the Source to avoid the need for cross Event synchronization. In addition to its name, one needs to give the file to read, e.g. </p><div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md9"></a>
SerialRootSource</h3>
<p>Reads a standard ROOT file. All concurrent Events share the same Source. Access to the Source is serialized for thread-safety. In addition to its name, one needs to give the file to read, e.g. </p><div class="fragment"><div class="line">&gt; threaded_io_test -s SerialRootSource=test.root -t 1 -n 1000</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md10"></a>
RepeatingRootSource</h3>
<p>Reads the first N events from a standard ROOT file at construction time. The deserialized data products are held in memory. Going from event to event is just a switch of the memory addresses to be used. In addition to its name, one needs to give the file to read and, optionally, the number of events to read (default is 10) and a singular TBranch to read, e.g.</p>
<div class="fragment"><div class="line">&gt; threaded_io_test -s RepeatingRootSource=test.root -t 1  -n 1000</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line">&gt; threaded_io_test -s RepeatingRootSource=test.root:repeat=5 -t 1 -n 1000</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line">&gt; threaded_io_test -s RepeatingRootSource=test.root:repeat=5:branchToRead=ints -t 1 -n 1000</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md11"></a>
ReplicatedPDSSource</h3>
<p>Reads a <em>packed data streams</em> format file. Each concurrent Event has its own replica of the Source to avoid the need for cross Event synchronization. In addition to its name, one needs to give the file to read, e.g. </p><div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedPDSSource=test.pds -t 1 -n 10</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md12"></a>
SharedPDSSource</h3>
<p>Reads a <em>packed data streams</em> format file. The Source is shared between the concurrent Events. Reads from the file are serialized for thread-safety while decompressing the Event and the object deserialization can proceed concurrently. In addition to its name, one needs to give the file to read, e.g. </p><div class="fragment"><div class="line">&gt; threaded_io_test -s SharedPDSSource=test.pds -t 1 -n 10</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md13"></a>
SharedRootEventSource</h3>
<p>Reads a ROOT file which only has 2 TBranches in the <code>Events</code> TTree. One branch holds the EventIdentifier. The other holds a (possibly pre-compressed) buffer of all the pre-object serialized data products in the event and a vector of offsets into that buffer for the beginning of each data products serialization. The Source is shared between the concurrent Events. Reads from the file are serialized for thread-safety and decompressing the Event happens at that time as well. The object deserialization can proceed concurrently. In addition to its name, one needs to give the file to read, e.g. </p><div class="fragment"><div class="line">&gt; threaded_io_test -s SharedRootEventSource=test.eroot -t 1 -n 10</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md14"></a>
SharedRootBatchEventsSource</h3>
<p>This is similar to SharedRootEventSource except this time each entry in the <code>Events</code> TTree is actually for a batch of Events. The <code>Events</code> TTree again only holds 2 TBranches. One branch holds a <code>std::vector&lt;EventIdentifier&gt;</code>. The other holds a (possibly pre-compressed) buffer of all the pre-object serialized data products for all the events in the batch and a vector of offsets into that buffer for the beginning of each data products serialization. The Source is shared between the concurrent Events. Reads from the file are serialized for thread-safety and decompressing the Event happens at that time as well. The object deserialization can proceed concurrently. In addition to its name, one needs to give the file to read, e.g. </p><div class="fragment"><div class="line">&gt; threaded_io_test -s SharedRootBatchEventsSource=test.eroot -t 1 -n 10</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
Outputers</h2>
<h3><a class="anchor" id="autotoc_md16"></a>
DummyOutputer</h3>
<p>Does no work. If no outputer is given, this is the one used. Specify by just using its name and optionally the option label 'useProductReady' </p><div class="fragment"><div class="line">&gt; threaded_io_test -s EmptySource -t 1 -n 10 -o DummyOutputer</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line">&gt; threaded_io_test -s EmptySource -t 1 -n 10 -o DummyOutputer=useProductReady</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md17"></a>
TextDumpOutputer</h3>
<p>Dumps the name and sizes for each data product. Specify by its name and the following optional parameters:</p><ul>
<li>perEvent: print names and sizes for each event. On by default. Allowed values are <code>perEvent=t</code>, <code>perEvent=f</code> and <code>perEvent</code> which is same as <code>perEvent=t</code>.</li>
<li>summary: at end of job, print names and average size per event. Off by default. Allowed values are <code>summary=t</code>, <code>summary=f</code>, and <code>summary</code> which is same as <code>summary=t</code>. <div class="fragment"><div class="line">&gt; threaded_io_test -s EmptySource -t 1 -n 10 -o TextDumpOutputer</div>
</div><!-- fragment --> or <div class="fragment"><div class="line">&gt; threaded_io_test -s EmptySource -t 1 -n 10 -o TextDumpOutputer=perEvent=f:summary=t</div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="autotoc_md18"></a>
SerializeOutputer</h3>
<p>Uses ROOT to serialize the <em>event</em> data products but does not store them. It prints timing statistics about the serialization. Specify by just using its name and an optional 'verbose' parameter </p><div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o SerializeOutputer</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o SerializeOutputer=verbose</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md19"></a>
TestProductsOutputer</h3>
<p>Checks that the data products match what is expected from TestProductsSource or files containing those same data products. If the results are unexpected, the program will abort. Specify by just using its name. </p><div class="fragment"><div class="line">&gt; threaded_io_test -s TestProductsSource -t 1 -n 10 -o TestProductsOutputer</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md20"></a>
RootOutputer</h3>
<p>Writes the <em>event</em> data products into a ROOT file. Specify both the name of the Outputer and the file to write as well as many optional parameters:</p><ul>
<li>splitLevel: split level for the branches, default 99</li>
<li>compressionLevel: compression level 0-9, default 9</li>
<li>compressionAlgorithm: name of compression algorithm. Allowed valued "", "ZLIB", "LZMA", "LZ4"</li>
<li>basketSize: default size of all baskets, default size 16384</li>
<li>treeMaxVirtualSize: Size of ROOT TTree TBasket cache. Use ROOT default if value is &lt;0. Default -1.</li>
<li>autoFlush: passed value to TTree SetAutoFlush. Use of the default value -1 means no call is made.</li>
<li>cacheSize: size in bytes passed to TFileCacheWrite. Use of the dafault value 0 means cache is set to 0. <div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o RootOutputer=test.root</div>
</div><!-- fragment --> or <div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o RootOutputer=test.root:splitLevel=1</div>
</div><!-- fragment --> or <div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o RootOutputer=test.root:splitLevel=1:cacheSize:1048576</div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="autotoc_md21"></a>
TBufferMergerRootOutputer</h3>
<p>Writes the <em>event</em> data products into a buffer that is then written to a ROOT file. Specify both the name of the Outputer and the file to write as well as many optional parameters:</p><ul>
<li>splitLevel: split level for the branches, default 99</li>
<li>compressionLevel: compression level 0-9, default 9</li>
<li>compressionAlgorithm: name of compression algorithm. Allowed valued "", "ZLIB", "LZMA", "LZ4"</li>
<li>basketSize: default size of all baskets, default size 16384</li>
<li>treeMaxVirtualSize: Size of ROOT TTree TBasket cache. Use ROOT default if value is &lt;0. Default -1.</li>
<li>autoFlush: passed value to TTree SetAutoFlush. Use of the default value -1 means no call is made.</li>
<li>cacheSize: size in bytes passed to TFileCacheWrite. Use of the dafault value 0 means cache is set to 0. <div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o TBufferMergerRootOutputer=test.root</div>
</div><!-- fragment --> or <div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o TBufferMergerRootOutputer=test.root:splitLevel=1</div>
</div><!-- fragment --> or <div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o TBufferMergerRootOutputer=test.root:splitLevel=1:cacheSize:1048576</div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="autotoc_md22"></a>
PDSOutputer</h3>
<p>Writes the <em>event</em> data products into a PDS file. Specify both the name of the Outputer and the file to write as well as compression options:</p><ul>
<li>compressionLevel: compression level. Allowed value depends on algorithm. For now ZSTD is the only one and allows values<ul>
<li>0 - 19 (negative values and values 20-22 are possible but not considered good choices by the zstandard authors)</li>
</ul>
</li>
<li>compressionAlgorithm: name of compression algorithm. Allowed valued "", "None", "ZSTD", "LZ4"</li>
<li>serializationAlgorithm: name of a serialization algorithm. Allowed values "", "ROOT", "ROOTUnrolled" or "Unrolled". The default is "ROOT" (which is the same as ""). Both <em>unrolled</em> names correspond to the same algorithm. <div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o PDSOutputer=test.pds</div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="autotoc_md23"></a>
HDFOutputer</h3>
<p>Writes the <em>event</em> data products into a HDF file. Specify both the name of the Outputer and the file to write as well as the number of events to <em>batch</em> together when writing::</p><ul>
<li>batchSize: number of events to batch together before writing out to the file. Default is 2. <div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o HDFOutputer=test.hdf</div>
</div><!-- fragment --> or <div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o HDFOutputer=test.hdf:batchSize=10</div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="autotoc_md24"></a>
HDFBatchEventsOutputer</h3>
<p>Writes the <em>event</em> data products into a HDF file where all data products for a batch of events are stored in a single dataset where the data products for all the events in the batch have been pre-object serialized into a <code>std::vector&lt;char&gt;</code>. Specify both the name of the Outputer and the file to write as well as many optional parameters:</p>
<ul>
<li>hdfchunkSize: HDF chunk size value to use for dataset. Default is 10485760.</li>
<li>batchSize: number of events to batch together when storing, default 1</li>
<li>compressionLevel: compression level. Allowed value depends on algorithm. For now ZSTD is the only one and allows values<ul>
<li>0 - 19 (negative values and values 20-22 are possible but not considered good choices by the zstandard authors)</li>
</ul>
</li>
<li>compressionAlgorithm: name of compression algorithm. Allowed values "", "None", "ZSTD", "LZ4"</li>
<li>compressionChoice: what to compress. Allowed values "None", "Events", "Batch", "Both". Default is "Events".</li>
<li>serializationAlgorithm: name of a serialization algorithm. Allowed values "", "ROOT", "ROOTUnrolled" or "Unrolled". The default is "ROOT" (which is the same as ""). Both <em>unrolled</em> names correspond to the same algorithm. <div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o RootBatchEventsOutputer=test.root</div>
</div><!-- fragment --> or <div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o RootBatchEventsOutputer=test.root:batchSize=4</div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="autotoc_md25"></a>
RootEventOutputer</h3>
<p>Writes the <em>event</em> data products into a ROOT file where all data products for an event are stored in a single TBranch where the data products have been pre-object serialized into a <code>std::vector&lt;char&gt;</code>. Specify both the name of the Outputer and the file to write as well as many optional parameters:</p>
<ul>
<li>tfileCompressionLevel: compression level to be used by ROOT 0-9, default 0</li>
<li>tfileCompressionAlgorithm: name of compression algorithm to be used by ROOT. Allowed valued "", "ZLIB", "LZMA", "LZ4"</li>
<li>treeMaxVirtualSize: Size of ROOT TTree TBasket cache. Use ROOT default if value is &lt;0. Default -1.</li>
<li>autoFlush: passed value to TTree SetAutoFlush. Use of the default value -1 means no call is made.</li>
<li>compressionLevel: compression level. Allowed value depends on algorithm. For now ZSTD is the only one and allows values<ul>
<li>0 - 19 (negative values and values 20-22 are possible but not considered good choices by the zstandard authors)</li>
</ul>
</li>
<li>compressionAlgorithm: name of compression algorithm. Allowed valued "", "None", "ZSTD", "LZ4"</li>
<li>serializationAlgorithm: name of a serialization algorithm. Allowed values "", "ROOT", "ROOTUnrolled" or "Unrolled". The default is "ROOT" (which is the same as ""). Both <em>unrolled</em> names correspond to the same algorithm. <div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o RootEventOutputer=test.root</div>
</div><!-- fragment --> or <div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o RootEventOutputer=test.root:compressionAlgorithm=LZ4</div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="autotoc_md26"></a>
RootBatchEventsOutputer</h3>
<p>Writes the <em>event</em> data products into a ROOT file where all data products for a batch of events are stored in a single TBranch where the data products for all the events in the batch have been pre-object serialized into a <code>std::vector&lt;char&gt;</code>. Specify both the name of the Outputer and the file to write as well as many optional parameters:</p>
<ul>
<li>batchSize: number of events to batch together when storing, default 1</li>
<li>tfileCompressionLevel: compression level to be used by ROOT 0-9, default 0</li>
<li>tfileCompressionAlgorithm: name of compression algorithm to be used by ROOT. Allowed valued "", "ZLIB", "LZMA", "LZ4"</li>
<li>treeMaxVirtualSize: Size of ROOT TTree TBasket cache. Use ROOT default if value is &lt;0. Default -1.</li>
<li>autoFlush: passed value to TTree SetAutoFlush. Use of the default value -1 means no call is made.</li>
<li>compressionLevel: compression level. Allowed value depends on algorithm. For now ZSTD is the only one and allows values<ul>
<li>0 - 19 (negative values and values 20-22 are possible but not considered good choices by the zstandard authors)</li>
</ul>
</li>
<li>compressionAlgorithm: name of compression algorithm. Allowed valued "", "None", "ZSTD", "LZ4"</li>
<li>serializationAlgorithm: name of a serialization algorithm. Allowed values "", "ROOT", "ROOTUnrolled" or "Unrolled". The default is "ROOT" (which is the same as ""). Both <em>unrolled</em> names correspond to the same algorithm. <div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o RootBatchEventsOutputer=test.root</div>
</div><!-- fragment --> or <div class="fragment"><div class="line">&gt; threaded_io_test -s ReplicatedRootSource=test.root -t 1 -n 10 -o RootBatchEventsOutputer=test.root:batchSize=4</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md27"></a>
Waiters</h2>
<h3><a class="anchor" id="autotoc_md28"></a>
ScaleWaiter</h3>
<p>For each data product this waiter sleeps for an amount of time proportional to the <code>size</code> property of the data product. The configuration options are:</p><ul>
<li>scale: used to convert the size property of the <em>event</em> data products into microseconds used for a call to sleep. A value of 0 means no sleeping.</li>
</ul>
<h3><a class="anchor" id="autotoc_md29"></a>
EventSleepWaiter</h3>
<p>This waiter reads a file containing the total time it should sleep for each event. If the number of events in the file is less than the total number of the job, the waiter will repeat the same sleep times. The order of the sleep times is guaranteed to line up with the order of Events coming from the Source. The waiter divides the event sleep time equally among all the data products. The configuration options are:</p><ul>
<li>filename: the name of the file containing the event sleep times. The event entries must be separated by white space. The sleep times are in microseconds.</li>
</ul>
<h3><a class="anchor" id="autotoc_md30"></a>
EventUnevenSleepWaiter</h3>
<p>Similar to EvenSleep Waiter, this waiter reads a file containing the total time it should sleep for each event. If the number of events in the file is less than the total number of the job, the waiter will repeat the same sleep times. The order of the sleep times is guaranteed to line up with the order of Events coming from the Source. The waiter divides the event sleep time equally among the number of data products specified by the configuration option. This numer must be less than or equal to the number of data products in the job. The configuration options are:</p><ul>
<li>filename: the name of the file containing the event sleep times. The event entries must be separated by white space. The sleep times are in microseconds.</li>
<li>divideBetween: how many tasks that should split the event time equally. Default is the number of data products in the job.</li>
<li>scale: a floating point value used to multiple with the event times in the file. Default is 1.0.</li>
</ul>
<h1><a class="anchor" id="autotoc_md31"></a>
unroll_test</h1>
<p>The <em>unroll_test</em> executable is meant to allow testing of the unrolled serialization process and allow comparison of object serialization sizes with respect to ROOT's standard serialization. The executable takes the following command line arguments</p>
<p>unroll_test [-g] [-s] [list of class names]</p>
<ul>
<li>-g : turns on ROOT verbose debugging output</li>
<li>-s : skips running the built in test cases</li>
<li>[list of class names] : names of C++ classes with ROOT dictionaries. The executable will perform serialization/deserialization on defaultly constructed instances of these classes and report the bytes needed for storage. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
